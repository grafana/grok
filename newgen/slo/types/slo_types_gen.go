package types

type Objective struct {
	// is a value between 0 and 1 if the value of the query's output
// is above the objective, the SLO is met.
Value float64 `json:"value"`
	// is a Prometheus-parsable time duration string like 24h, 60m. This is the time
// window the objective is measured over.
Window string `json:"window"`
}

type Query struct {
}

type ThresholdQuery struct {
	GroupByLabels []string `json:"groupByLabels,omitempty"`
	ThresholdMetric MetricDef `json:"thresholdMetric"`
	Threshold Threshold `json:"threshold"`
}

type RatioQuery struct {
	GroupByLabels []string `json:"groupByLabels,omitempty"`
	SuccessMetric MetricDef `json:"successMetric"`
	TotalMetric MetricDef `json:"totalMetric"`
}

type HistogramQuery struct {
	GroupByLabels []string `json:"groupByLabels,omitempty"`
	HistogramMetric MetricDef `json:"histogramMetric"`
	Percentile float64 `json:"percentile"`
	Threshold Threshold `json:"threshold"`
}

type FreeformQuery struct {
	FreeformQuery string `json:"freeformQuery"`
}

type Threshold struct {
	Value float64 `json:"value"`
	Operator OperatorEnum `json:"operator"`
}

type MetricDef struct {
	PrometheusMetric string `json:"prometheusMetric"`
	Type *string `json:"type,omitempty"`
}

type GrafanaMetadata struct {
	OrganizationId string `json:"organizationId"`
	UserEmail string `json:"userEmail"`
	UserName string `json:"userName"`
	Provenance string `json:"provenance"`
}

type Label struct {
	Key string `json:"key"`
	Value string `json:"value"`
}

type AlertingMetadata struct {
	Labels []Label `json:"labels,omitempty"`
	Annotations []Label `json:"annotations,omitempty"`
}

type Alerting struct {
	// will be attached to all alerts generated by any of these rules.
Labels []Label `json:"labels,omitempty"`
	// will be attached to all alerts generated by any of these rules.
Annotations []Label `json:"annotations,omitempty"`
	// Metadata to attach only to fastBurn alerts.
FastBurn *AlertingMetadata `json:"fastBurn,omitempty"`
	// Metadata to attach only to slowBurn alerts.
SlowBurn *AlertingMetadata `json:"slowBurn,omitempty"`
}

// metadata contains embedded CommonMetadata and can be extended with custom string fields
// TODO: use CommonMetadata instead of redefining here; currently needs to be defined here
// without external reference as using the CommonMetadata reference breaks thema codegen.
type Metadata struct {
	UpdateTimestamp string `json:"updateTimestamp"`
	CreatedBy string `json:"createdBy"`
	UpdatedBy string `json:"updatedBy"`
	Uid string `json:"uid"`
	CreationTimestamp string `json:"creationTimestamp"`
	DeletionTimestamp *string `json:"deletionTimestamp,omitempty"`
	Finalizers []string `json:"finalizers"`
	ResourceVersion string `json:"resourceVersion"`
	// extraFields is reserved for any fields that are pulled from the API server metadata but do not have concrete fields in the CUE metadata
ExtraFields any `json:"extraFields"`
	Labels map[string]string `json:"labels"`
}

type Spec struct {
	// This is used internally by the plugin for permission management and
// similar functions.
GrafanaMetadata *GrafanaMetadata `json:"grafanaMetadata,omitempty"`
	// A unique, random identifier. This value will also be the name of the
// resource stored in the API server. Must be set for a PUT.
Uuid string `json:"uuid"`
	// should be a short description of your indicator. Consider names like
// "API Availability"
Name string `json:"name"`
	// is a free-text field that can provide more context to an
// SLO. It is shown on SLO drill-down dashboards and in hover text on
// the SLO summary dashboard.
Description string `json:"description"`
	// describes the indicator that will be measured against the
// objective. Four query types are supported:
// 1. Ratio Queries provide a successMetric and totalMetric whose ratio is the SLI.
// 2. Threshold Queries provide a thresholdMetric and a threshold. The
//    SLI is the boolean result of evaluating the threshould.
// 3. Histogram Queries are similar to threshold queries, but the use a
//    Prometheus histogram metric, percentile value, and a threshold to
//    generate the boolean output.
// 4. Freeform Queries supply a single freeFormQuery string that is
//    evaluated to produce the SLI output. The value should range beween 0
//    and 1.0. Freeform queries should include a time variable named
//    either `$__rate_interval`,`$__interval` or `$__range`. This will be used by the
//    tool to evaluate the burn rate of an SLO over various time
//    windows. Queries that don't include this interval will have
//    sensitive and imprecise alerting.
// Additionally, "groupByLabels" are used in the first three query types
// to define how to group series for evaluation. They are discarded for
// freeform queries.
Query Query `json:"query"`
	// You can have multiple time windows and objectives associated with an
// SLO. Over each rolling time window, the remaining error budget will
// be calculated, and separate alerts can be generated for each time
// window based on the SLO burn rate or remaining error budget.
Objectives []Objective `json:"objectives"`
	// Any additional labels that will be attached to all metrics generated
// from the query. These labels are useful for grouping SLOs in
// dashboard views that you create by hand.
// The key must match the prometheus label requirements regex:
// "^[a-zA-Z_][a-zA-Z0-9_]*$"
Labels []Label `json:"labels,omitempty"`
	// Configures the alerting rules that will be generated for each
// time window associated with the SLO. Grafana SLOs can generate
// alerts when the short-term error budget burn is very high, the
// long-term error budget burn rate is high, or when the remaining
// error budget is below a certain threshold.
Alerting *Alerting `json:"alerting,omitempty"`
}

type OperatorState struct {
	// lastEvaluation is the ResourceVersion last evaluated
LastEvaluation string `json:"lastEvaluation"`
	// state describes the state of the lastEvaluation.
// It is limited to three possible states for machine evaluation.
State StateEnum `json:"state"`
	// descriptiveState is an optional more descriptive state field which has no requirements on format
DescriptiveState *string `json:"descriptiveState,omitempty"`
	// details contains any extra information that is operator-specific
Details any `json:"details,omitempty"`
}

// Status is a common kubernetes subresource that is used to provide
// information about the current state, that isn't a direct part of the
// resource. Here we use it to provide a pointer to the generated
// dashboard.
type Status struct {
	DrillDownDashboard struct {
	Uid string `json:"uid"`
	// The generation of the SLO when this dashboard was last updated.
ReconciledForGeneration string `json:"reconciledForGeneration"`
	LastError string `json:"lastError"`
} `json:"drillDownDashboard"`
	// operatorStates is a map of operator ID to operator state evaluations.
// Any operator which consumes this kind SHOULD add its state evaluation information to this field.
OperatorStates any `json:"operatorStates,omitempty"`
	PrometheusRules struct {
	// The generation of the SLO when these rules were last updated.
ReconciledForGeneration string `json:"reconciledForGeneration"`
	LastError string `json:"lastError"`
} `json:"prometheusRules"`
	// additionalFields is reserved for future use
AdditionalFields any `json:"additionalFields,omitempty"`
}

type OperatorEnum string
const (
	Operator< OperatorEnum = "<"
	Operator<= OperatorEnum = "<="
	Operator== OperatorEnum = "=="
	Operator>= OperatorEnum = ">="
	Operator> OperatorEnum = ">"
)

type StateEnum string
const (
	StateSuccess StateEnum = "success"
	StateInProgress StateEnum = "in_progress"
	StateFailed StateEnum = "failed"
)

